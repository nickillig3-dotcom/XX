diff --git a/src/perps/data_providers/binance.py b/src/perps/data_providers/binance.py
new file mode 100644
--- /dev/null
+++ b/src/perps/data_providers/binance.py
@@
+from __future__ import annotations
+
+from datetime import datetime, timezone
+from typing import Iterable, List
+
+import httpx
+from pydantic import BaseModel, field_validator
+
+BINANCE_FAPI_BASE = "https://fapi.binance.com"
+
+
+class PremiumIndex(BaseModel):
+    symbol: str
+    markPrice: float
+    indexPrice: float
+    lastFundingRate: float
+    nextFundingTime: datetime | None = None
+    time: datetime
+
+    @field_validator("markPrice", "indexPrice", "lastFundingRate", mode="before")
+    @classmethod
+    def _parse_str_floats(cls, v):
+        if isinstance(v, str):
+            return float(v)
+        return v
+
+    @field_validator("time", mode="before")
+    @classmethod
+    def _parse_time_ms(cls, v):
+        # Binance returns ms epoch
+        if isinstance(v, (int, float)):
+            return datetime.fromtimestamp(v / 1000.0, tz=timezone.utc)
+        return v
+
+    @field_validator("nextFundingTime", mode="before")
+    @classmethod
+    def _parse_next_funding_ms(cls, v):
+        if v in (None, 0):
+            return None
+        if isinstance(v, (int, float)):
+            # Some endpoints provide ms epoch; others seconds. Assume ms if large.
+            if v > 10**12:
+                return datetime.fromtimestamp(v / 1000.0, tz=timezone.utc)
+            return datetime.fromtimestamp(v, tz=timezone.utc)
+        return v
+
+
+def fetch_premium_index(symbols: Iterable[str]) -> List[PremiumIndex]:
+    """
+    Fetch premium index (public; no API key) for given symbols.
+    Endpoint: GET /fapi/v1/premiumIndex?symbol=BTCUSDT
+    """
+    out: List[PremiumIndex] = []
+    with httpx.Client(base_url=BINANCE_FAPI_BASE, timeout=10) as client:
+        for sym in symbols:
+            r = client.get("/fapi/v1/premiumIndex", params={"symbol": sym})
+            r.raise_for_status()
+            data = r.json()
+            out.append(PremiumIndex.model_validate(data))
+    return out
+
diff --git a/src/perps/signals/basis.py b/src/perps/signals/basis.py
new file mode 100644
--- /dev/null
+++ b/src/perps/signals/basis.py
@@
+from __future__ import annotations
+
+from datetime import datetime, timezone
+
+from ..core.types import Signal, SignalSet
+from ..data_providers.binance import PremiumIndex
+
+
+def compute_basis_percent(pi: PremiumIndex) -> float:
+    if pi.indexPrice == 0:
+        return 0.0
+    return (pi.markPrice - pi.indexPrice) / pi.indexPrice * 100.0
+
+
+def to_signalset(source: str, items: list[PremiumIndex]) -> SignalSet:
+    sigs: list[Signal] = []
+    now = datetime.now(timezone.utc)
+    for it in items:
+        basis = round(compute_basis_percent(it), 4)
+        funding_bps = round(it.lastFundingRate * 10000, 2)  # 1% = 10000 bps on Binance FR? Actually FR is fraction per 8h.
+        sigs.append(Signal(symbol=it.symbol, name="basis_percent", value=basis, at=it.time))
+        sigs.append(Signal(symbol=it.symbol, name="funding_rate_pct", value=round(it.lastFundingRate * 100, 6), at=it.time))
+        sigs.append(Signal(symbol=it.symbol, name="funding_bps", value=funding_bps, at=it.time))
+    return SignalSet(source=source, generated_at=now, items=sigs)
+
diff --git a/src/perps/cli.py b/src/perps/cli.py
--- a/src/perps/cli.py
+++ b/src/perps/cli.py
@@
-from pathlib import Path
+from pathlib import Path
+import json
+from datetime import datetime, timezone
+
+from .data_providers.binance import PremiumIndex, fetch_premium_index
+from .signals.basis import to_signalset
@@
-def cmd_fetch() -> None:
-    """
-    Placeholder: Später öffentliche Marktdaten holen (ohne API-Keys) und unter data/ ablegen.
-    """
-    data_dir = Path("data")
-    data_dir.mkdir(parents=True, exist_ok=True)
-    (data_dir / "README.txt").write_text("Hier landen rohe Public-Daten (Samples).", encoding="utf-8")
-    print("fetch: ok (placeholder)")
+def cmd_fetch() -> None:
+    """
+    Fetch ausgewählter Symbole (ohne API-Key) und Rohdaten unter data/ ablegen.
+    """
+    data_dir = Path("data")
+    data_dir.mkdir(parents=True, exist_ok=True)
+    symbols = ["BTCUSDT", "ETHUSDT"]
+    items: list[PremiumIndex] = fetch_premium_index(symbols)
+    snap = {
+        "fetched_at": datetime.now(timezone.utc).isoformat(),
+        "items": [it.model_dump(mode="json") for it in items],
+    }
+    (data_dir / "premiumindex_latest.json").write_text(json.dumps(snap, indent=2), encoding="utf-8")
+    print(f"fetch: wrote {(data_dir / 'premiumindex_latest.json')}")
@@
-def cmd_signals() -> None:
-    """
-    Placeholder: Aus Daten einfache Signale (Basis/Funding-Flags) berechnen und als JSON schreiben.
-    """
-    out = DOCS_DIR / "signals.json"
-    DOCS_DIR.mkdir(parents=True, exist_ok=True)
-    out.write_text('{"status":"placeholder","signals":[]}', encoding="utf-8")
-    print(f"signals: wrote {out}")
+def cmd_signals() -> None:
+    """
+    Signale aus den zuletzt geholten Daten generieren und als JSON unter docs/ ablegen.
+    """
+    data_path = Path("data/premiumindex_latest.json")
+    if not data_path.exists():
+        raise SystemExit("Keine Daten vorhanden. Erst `python -m perps.cli fetch` ausführen.")
+    snap = json.loads(data_path.read_text(encoding="utf-8"))
+    items = [PremiumIndex.model_validate(x) for x in snap["items"]]
+    sset = to_signalset(source="binance_premiumindex", items=items)
+    DOCS_DIR.mkdir(parents=True, exist_ok=True)
+    out = DOCS_DIR / "signals.json"
+    out.write_text(sset.model_dump_json(indent=2), encoding="utf-8")
+    print(f"signals: wrote {out}")
diff --git a/tests/test_binance_parse.py b/tests/test_binance_parse.py
new file mode 100644
--- /dev/null
+++ b/tests/test_binance_parse.py
@@
+import json
+from pathlib import Path
+
+from perps.data_providers.binance import PremiumIndex
+from perps.signals.basis import compute_basis_percent, to_signalset
+
+
+def test_parse_premiumindex_sample():
+    sample = json.loads(Path("tests/fixtures/binance_premiumindex_sample.json").read_text(encoding="utf-8"))
+    item = PremiumIndex.model_validate(sample[0])
+    assert item.symbol == "BTCUSDT"
+    assert item.markPrice > 0 and item.indexPrice > 0
+    # basis should be positive for this sample
+    basis = compute_basis_percent(item)
+    assert basis > 0
+
+
+def test_signalset_shapes():
+    sample = json.loads(Path("tests/fixtures/binance_premiumindex_sample.json").read_text(encoding="utf-8"))
+    items = [PremiumIndex.model_validate(x) for x in sample]
+    sset = to_signalset(source="binance_premiumindex", items=items)
+    assert sset.source == "binance_premiumindex"
+    assert len(sset.items) >= 3  # 3 signals per symbol
+    names = {s.name for s in sset.items}
+    assert {"basis_percent", "funding_rate_pct", "funding_bps"} <= names
+
diff --git a/tests/fixtures/binance_premiumindex_sample.json b/tests/fixtures/binance_premiumindex_sample.json
new file mode 100644
--- /dev/null
+++ b/tests/fixtures/binance_premiumindex_sample.json
@@
+[
  {
    "symbol": "BTCUSDT",
    "markPrice": "65000.00000000",
    "indexPrice": "64850.00000000",
    "estimatedSettlePrice": "64900.00000000",
    "lastFundingRate": "0.00010000",
    "interestRate": "0.00010000",
    "nextFundingTime": 253402300799,
    "time": 1700000000000
  }
]
